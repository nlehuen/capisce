<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Capisce by nlehuen</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Capisce</h1>
<p>A small CPS-style utility library for node.js</p>
        <p class="view"><a href="https://github.com/nlehuen/capisce">View the Project on GitHub <small>nlehuen/capisce</small></a></p>
        <ul>
          <li><a href="https://github.com/nlehuen/capisce/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/nlehuen/capisce/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/nlehuen/capisce">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>capisce</h1>

<p>This module implements an asynchronous job queueing system with the WorkingQueue class. Jobs are processed concurrently up to a given degree of "concurrency" ; of course, if this degree is 1, then jobs are processed sequentially.</p>

<p>The basic use case of this module is when you want to perform a bunch (hundreds or thousands) of I/O related tasks, for instance HTTP requests. In order to play nice with others and make sure the I/O stack (file descriptors, TCP/IP stack etc.) won't be submerged by thousands of concurrent requests, you have to put an artificial limit on the requests that are launched concurrently. When this limit is reached, jobs have to be queued until some other job is finished. And that's exactly what WorkingQueue is for !</p>

<h2>The WorkingQueue class</h2>

<h3>Creating a queue</h3>

<p>This class is instanciated with a single parameter : the concurrency level of the queue. Again, if the concurrency level is 1, then it means that all jobs will be processed sequentially.</p>

<div class="highlight">
<pre><span class="kd">var</span> <span class="nx">WorkingQueue</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'capisce'</span><span class="p">).</span><span class="nx">WorkingQueue</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkingQueue</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
</pre>
</div>


<h3>Launching jobs</h3>

<p>You can then launch jobs using the perform method. If the current concurrency limit has not been reached, then the job will be scheduled immediatly. Otherwise, it is queued for later execution.</p>

<p>Jobs are simple functions that are passed a very important parameter : the over function. The job MUST call the over function at the end of its process to signal the WorkingQueue that it is, well, over.</p>

<div class="highlight">
<pre><span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello, world !"</span><span class="p">);</span>
    <span class="nx">over</span><span class="p">();</span>
<span class="p">});</span>
</pre>
</div>


<p>The over function can be passed around inside your job. In fact it's the only way to perform interesting things : since I/O are asynchronous, you have to call over once the I/O request is over, that is to say in an event handler or completion callback.</p>

<div class="highlight">
<pre><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Reading file..."</span><span class="p">);</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">'README.md'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Over !"</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">stdout</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">over</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">});</span>
</pre>
</div>


<p>Of course you can name the over function any way you want. Other similar libraries like to call it done.</p>

<h3>Passing parameters to jobs</h3>

<p>Before 0.4.0, jobs where function that could only take one parameter, the over function. This forced any job parameters to be passed through the closure mechanism, which may have undesirable memory or performance downsides.</p>

<p>From 0.4.0, you can pass additional arguments to the perform call and they will be passed right along to your job, before the over function. Internally the data stored in the queue is [job, arg1, arg2...] so no surprises regarding memory usage.</p>

<p>Here is a sample of parameter passing :</p>

<div class="highlight">
<pre><span class="c1">// Note how the over function is passed as the last parameter</span>
<span class="kd">function</span> <span class="nx">myJob</span><span class="p">(</span><span class="nx">word1</span><span class="p">,</span> <span class="nx">word2</span><span class="p">,</span> <span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">''</span> <span class="o">+</span> <span class="nx">word1</span> <span class="o">+</span> <span class="s1">', '</span> <span class="o">+</span> <span class="nx">word2</span> <span class="o">+</span> <span class="s1">' !'</span><span class="p">);</span>
    <span class="nx">over</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="nx">myJob</span><span class="p">,</span> <span class="s1">'Hello'</span><span class="p">,</span> <span class="s1">'world'</span><span class="p">);</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="nx">myJob</span><span class="p">,</span> <span class="s1">'Howdy'</span><span class="p">,</span> <span class="s1">'pardner'</span><span class="p">);</span>
</pre>
</div>


<h3>Waiting for all jobs to be over</h3>

<p>When queuing a bunch of jobs, it is often required to wait for all jobs to complete before continuing a process. For that you use the whenDone method :</p>

<div class="highlight">
<pre><span class="kd">function</span> <span class="nx">myJob</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">duration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Starting "</span><span class="o">+</span><span class="nx">name</span><span class="o">+</span><span class="s2">" for "</span><span class="o">+</span><span class="nx">duration</span><span class="o">+</span><span class="s2">"ms"</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">" over, duration="</span><span class="o">+</span><span class="nx">duration</span><span class="o">+</span><span class="s2">"ms"</span><span class="p">);</span>
        <span class="nx">over</span><span class="p">();</span>
    <span class="p">},</span> <span class="nx">duration</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="nx">myJob</span><span class="p">,</span> <span class="s2">"job-"</span><span class="o">+</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">whenDone</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"All done !"</span><span class="p">);</span>
<span class="p">});</span>
</pre>
</div>


<p>The whenDone method can be called multiple times to register multiple handlers, and the handlers will be called in the same order they were added. Maybe I should have used the EventEmitter pattern for this.</p>

<p>From 0.4.1 the situation when whenDone() callbacks are called is more precise.</p>

<p>The whenDone callbacks will be called :
- when the last job from the queue is over
- when you call doneAddingJobs() and no job was performed since the last whenDone situation</p>

<p>This is required to handle the case when a queue may or may not receive jobs, and you want cleanup callbacks to be called in both situations. In this case you would do :</p>

<div class="highlight">
<pre><span class="kd">function</span> <span class="nx">myJob</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">duration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Starting "</span><span class="o">+</span><span class="nx">name</span><span class="o">+</span><span class="s2">" for "</span><span class="o">+</span><span class="nx">duration</span><span class="o">+</span><span class="s2">"ms"</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">" over, duration="</span><span class="o">+</span><span class="nx">duration</span><span class="o">+</span><span class="s2">"ms"</span><span class="p">);</span>
        <span class="nx">over</span><span class="p">();</span>
    <span class="p">},</span> <span class="nx">duration</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="c1">// In some cases you can have no queued jobs</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="nx">myJob</span><span class="p">,</span> <span class="s2">"job-"</span><span class="o">+</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">whenDone</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"All done with "</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="s2">" jobs !"</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// This does nothing if jobs where added to the queue</span>
<span class="c1">// If no jobs where added, the whenDone callbacks are called</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">doneAddingJobs</span><span class="p">();</span>
</pre>
</div>


<p>Calling doneAddingJobs() is not mandatory : it's just needed if you want to make sure the whenDone callbacks are called even if no job was effectively done.</p>

<h3>Holding and resuming jobs execution</h3>

<p>Since capisce 0.2.0, if you want to fill in the queue first, then launch jobs later, you can use the hold and go methods :</p>

<div class="highlight">
<pre><span class="nx">queue</span><span class="p">.</span><span class="nx">hold</span><span class="p">();</span> <span class="c1">// Hold queue processing</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="nx">myJob</span><span class="p">,</span> <span class="s2">"job-"</span><span class="o">+</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">go</span><span class="p">();</span> <span class="c1">// Resume queue processing</span>
</pre>
</div>


<h3>Scheduling jobs for later</h3>

<p>Since capisce 0.3.0, you can use the wait method as a convenient way to include delays into job execution.</p>

<div class="highlight">
<pre><span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkingQueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Basically, a sequence</span>

<span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Waiting 5 seconds..."</span><span class="p">);</span>
    <span class="nx">over</span><span class="p">();</span>
<span class="p">}).</span><span class="nx">wait</span><span class="p">(</span><span class="mi">5000</span><span class="p">).</span><span class="nx">perform</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"done !"</span><span class="p">);</span>
    <span class="nx">over</span><span class="p">();</span>
<span class="p">});</span>
</pre>
</div>


<p>Of course the above example would be useless with some concurrency in the queue. If you want concurrency, you can pass a job parameter to wait :</p>

<div class="highlight">
<pre><span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WorkingQueue</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>

<span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"First job done"</span><span class="p">);</span>
    <span class="nx">over</span><span class="p">();</span>
<span class="p">}).</span><span class="nx">wait</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">over</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Second job started after 5 seconds"</span><span class="p">);</span>
    <span class="nx">over</span><span class="p">();</span>
<span class="p">});</span>
</pre>
</div>


<h2>The CollectingWorkingQueue class</h2>

<p>This is just a wrapper around WorkingQueue that do the very common task of collecting result of each job. When using CollectingWorkingQueue, the over function takes the err, result of the job as parameters, and the wellDone handler receive the array of job results (as [jobId, err, result] sub-arrays). It is your choice to sort this array if you want to have results in the same orders the jobs where submitted.</p>

<div class="highlight">
<pre><span class="kd">var</span> <span class="nx">queue2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CollectingWorkingQueue</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">myJob</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">duration</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Starting "</span><span class="o">+</span><span class="nx">name</span><span class="o">+</span><span class="s2">" for "</span><span class="o">+</span><span class="nx">duration</span><span class="o">+</span><span class="s2">"ms"</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">" over, duration="</span><span class="o">+</span><span class="nx">duration</span><span class="o">+</span><span class="s2">"ms"</span><span class="p">);</span>
        <span class="nx">over</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">"result-"</span><span class="o">+</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">duration</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">perform</span><span class="p">(</span><span class="nx">myJob</span><span class="p">,</span> <span class="s2">"job-"</span><span class="o">+</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">queue</span><span class="p">.</span><span class="nx">whenDone</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"All done !"</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Before sorting : "</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="mi">999</span><span class="p">]);</span>

    <span class="nx">results</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"After sorting : "</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">[</span><span class="mi">999</span><span class="p">]);</span>
<span class="p">});</span>
</pre>
</div>


<h2>Higher order constructs : sequence, concurrently, and then</h2>

<p>capisce exports the sequence and concurrently function, as well as the then method in order to provide a small DSL for asynchronous workflows, without exposing the gory details of WorkingQueue. See test/test2.js and test/test3.js until I write some proper doc for this.</p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/nlehuen">nlehuen</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA–5928887–3");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>