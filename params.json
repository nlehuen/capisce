{"name":"Capisce","body":"capisce\r\n=======\r\n\r\nThis module implements an asynchronous job queueing system with the WorkingQueue class. Jobs are processed concurrently up to a given degree of \"concurrency\" ; of course, if this degree is 1, then jobs are processed sequentially.\r\n\r\nThe basic use case of this module is when you want to perform a bunch (hundreds or thousands) of I/O related tasks, for instance HTTP requests. In order to play nice with others and make sure the I/O stack (file descriptors, TCP/IP stack etc.) won't be submerged by thousands of concurrent requests, you have to put an artificial limit on the requests that are launched concurrently. When this limit is reached, jobs have to be queued until some other job is finished. And that's exactly what WorkingQueue is for !\r\n\r\nThe WorkingQueue class\r\n----------------------\r\n\r\n### Creating a queue\r\n\r\nThis class is instanciated with a single parameter : the concurrency level of the queue. Again, if the concurrency level is 1, then it means that all jobs will be processed sequentially.\r\n\r\n```javascript\r\nvar WorkingQueue = require('capisce').WorkingQueue;\r\nvar queue = new WorkingQueue(16);\r\n```\r\n\r\n### Launching jobs\r\n\r\nYou can then launch jobs using the perform method. If the current concurrency limit has not been reached, then the job will be scheduled immediatly. Otherwise, it is queued for later execution.\r\n\r\nJobs are simple functions that are passed a very important parameter : the over function. The job MUST call the over function at the end of its process to signal the WorkingQueue that it is, well, over.\r\n\r\n```javascript\r\nqueue.perform(function(over) {\r\n    console.log(\"Hello, world !\");\r\n    over();\r\n});\r\n```\r\n\r\nThe over function can be passed around inside your job. In fact it's the only way to perform interesting things : since I/O are asynchronous, you have to call over once the I/O request is over, that is to say in an event handler or completion callback.\r\n\r\n```javascript\r\nvar fs = require('fs');\r\nqueue.perform(function(over) {\r\n    console.log(\"Reading file...\");\r\n    fs.readFile('README.md', function(err, result) {\r\n        console.log(\"Over !\");\r\n        if(err) {\r\n            console.error(err);\r\n        } else {\r\n            stdout.write(result);\r\n        }\r\n        over();\r\n    });\r\n});\r\n```\r\n\r\nOf course you can name the over function any way you want. Other similar libraries like to call it done.\r\n\r\n### Passing parameters to jobs\r\n\r\nBefore 0.4.0, jobs where function that could only take one parameter, the over function. This forced any job parameters to be passed through the closure mechanism, which may have undesirable memory or performance downsides.\r\n\r\nFrom 0.4.0, you can pass additional arguments to the perform call and they will be passed right along to your job, before the over function. Internally the data stored in the queue is [job, arg1, arg2...] so no surprises regarding memory usage.\r\n\r\nHere is a sample of parameter passing :\r\n\r\n```javascript\r\n// Note how the over function is passed as the last parameter\r\nfunction myJob(word1, word2, over) {\r\n    console.log('' + word1 + ', ' + word2 + ' !');\r\n    over();\r\n}\r\n\r\nqueue.perform(myJob, 'Hello', 'world');\r\nqueue.perform(myJob, 'Howdy', 'pardner');\r\n```\r\n\r\n### Waiting for all jobs to be over\r\n\r\nWhen queuing a bunch of jobs, it is often required to wait for all jobs to complete before continuing a process. For that you use the whenDone method :\r\n\r\n```javascript\r\nfunction myJob(name, over) {\r\n    var duration = Math.floor(Math.random() * 1000);\r\n    console.log(\"Starting \"+name+\" for \"+duration+\"ms\");\r\n    setTimeout(function() {\r\n        console.log(name + \" over, duration=\"+duration+\"ms\");\r\n        over();\r\n    }, duration);\r\n}\r\n\r\nvar i;\r\nfor(i=0;i<1000;i++) {\r\n    queue.perform(myJob, \"job-\"+i);\r\n}\r\nqueue.whenDone(function() {\r\n    console.log(\"All done !\");\r\n});\r\n```\r\n\r\nThe whenDone method can be called multiple times to register multiple handlers, and the handlers will be called in the same order they were added. Maybe I should have used the EventEmitter pattern for this.\r\n\r\nFrom 0.4.1 the situation when whenDone() callbacks are called is more precise.\r\n\r\nThe whenDone callbacks will be called :\r\n- when the last job from the queue is over\r\n- when you call doneAddingJobs() and no job was performed since the last whenDone situation\r\n\r\nThis is required to handle the case when a queue may or may not receive jobs, and you want cleanup callbacks to be called in both situations. In this case you would do :\r\n\r\n```javascript\r\nfunction myJob(name, over) {\r\n    var duration = Math.floor(Math.random() * 1000);\r\n    console.log(\"Starting \"+name+\" for \"+duration+\"ms\");\r\n    setTimeout(function() {\r\n        console.log(name + \" over, duration=\"+duration+\"ms\");\r\n        over();\r\n    }, duration);\r\n}\r\n\r\nvar i;\r\n// In some cases you can have no queued jobs\r\nfor(i=0;i<Math.random(10);i++) {\r\n    queue.perform(myJob, \"job-\"+i);\r\n}\r\nqueue.whenDone(function() {\r\n    console.log(\"All done with \"+i+\" jobs !\");\r\n});\r\n\r\n// This does nothing if jobs where added to the queue\r\n// If no jobs where added, the whenDone callbacks are called\r\nqueue.doneAddingJobs();\r\n```\r\n\r\nCalling doneAddingJobs() is not mandatory : it's just needed if you want to make sure the whenDone callbacks are called even if no job was effectively done.\r\n\r\n### Holding and resuming jobs execution\r\n\r\nSince capisce 0.2.0, if you want to fill in the queue first, then launch jobs later, you can use the hold and go methods :\r\n\r\n```javascript\r\nqueue.hold(); // Hold queue processing\r\nfor(i=0;i<1000;i++) {\r\n    queue.perform(myJob, \"job-\"+i);\r\n}\r\nqueue.go(); // Resume queue processing\r\n```\r\n\r\n### Scheduling jobs for later\r\n\r\nSince capisce 0.3.0, you can use the wait method as a convenient way to include delays into job execution.\r\n\r\n```javascript\r\nvar queue = new WorkingQueue(1); // Basically, a sequence\r\n\r\nqueue.perform(function(over) {\r\n    console.log(\"Waiting 5 seconds...\");\r\n    over();\r\n}).wait(5000).perform(function(over) {\r\n    console.log(\"done !\");\r\n    over();\r\n});\r\n```\r\n\r\nOf course the above example would be useless with some concurrency in the queue. If you want concurrency, you can pass a job parameter to wait :\r\n\r\n```javascript\r\nvar queue = new WorkingQueue(16);\r\n\r\nqueue.perform(function(over) {\r\n    console.log(\"First job done\");\r\n    over();\r\n}).wait(5000, function(over) {\r\n    console.log(\"Second job started after 5 seconds\");\r\n    over();\r\n});\r\n```\r\n\r\n\r\nThe CollectingWorkingQueue class\r\n--------------------------------\r\n\r\nThis is just a wrapper around WorkingQueue that do the very common task of collecting result of each job. When using CollectingWorkingQueue, the over function takes the err, result of the job as parameters, and the wellDone handler receive the array of job results (as [jobId, err, result] sub-arrays). It is your choice to sort this array if you want to have results in the same orders the jobs where submitted.\r\n\r\n```javascript\r\nvar queue2 = new CollectingWorkingQueue(16);\r\n\r\nfunction myJob(name) {\r\n    var duration = Math.floor(Math.random() * 1000);\r\n    console.log(\"Starting \"+name+\" for \"+duration+\"ms\");\r\n    setTimeout(function() {\r\n        console.log(name + \" over, duration=\"+duration+\"ms\");\r\n        over(null, \"result-\"+name);\r\n    }, duration);\r\n}\r\n\r\nvar i;\r\nfor(i=0;i<1000;i++) {\r\n    queue.perform(myJob, \"job-\"+i);\r\n}\r\nqueue.whenDone(function(results) {\r\n    console.log(\"All done !\");\r\n    \r\n    console.log(\"Before sorting : \")\r\n    console.log(results[0]);\r\n    console.log(results[999]);\r\n    \r\n    results.sort()\r\n    console.log(\"After sorting : \")\r\n    console.log(results[0]);\r\n    console.log(results[999]);\r\n});\r\n```\r\n\r\nHigher order constructs : sequence, concurrently, and then\r\n------------------------------------------------------\r\n\r\ncapisce exports the sequence and concurrently function, as well as the then method in order to provide a small DSL for asynchronous workflows, without exposing the gory details of WorkingQueue. See test/test2.js and test/test3.js until I write some proper doc for this.","tagline":"A small CPS-style utility library for node.js","google":"UA–5928887–3","note":"Don't delete this file! It's used internally to help with page regeneration."}